# Copyright (c) 2013-2024 by Ron Frederick <ronf@timeheart.net> and others.
#
# This program and the accompanying materials are made available under
# the terms of the Eclipse Public License v2.0 which accompanies this
# distribution and is available at:
#
#     http://www.eclipse.org/legal/epl-2.0/
#
# This program may also be made available under the following secondary
# licenses when the conditions for such availability set forth in the
# Eclipse Public License v2.0 are satisfied:
#
#    GNU General Public License, Version 2.0, or any later versions of
#    that license
#
# SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
#
# Contributors:
#     Ron Frederick - initial implementation, API, and documentation

"""SSH Diffie-Hellman, ECDH, and Edwards DH key exchange handlers"""

from hashlib import sha1, sha224, sha256, sha384, sha512
from typing import TYPE_CHECKING, Callable, Mapping, Optional, cast
from typing_extensions import Protocol

from .constants import DEFAULT_LANG
from .crypto import Curve25519DH, Curve448DH, DH, ECDH, PQDH
from .crypto import curve25519_available, curve448_available
from .crypto import mlkem_available, sntrup_available
from .gss import GSSError
from .kex import Kex, register_kex_alg, register_gss_kex_alg
from .misc import HashType, KeyExchangeFailed, ProtocolError
from .misc import get_symbol_names, run_in_executor
from .packet import Boolean, MPInt, String, UInt32, SSHPacket
from .public_key import SigningKey, VerifyingKey


if TYPE_CHECKING:
    # pylint: disable=cyclic-import
    from .connection import SSHConnection, SSHClientConnection
    from .connection import SSHServerConnection


class DHKey(Protocol):
    """Protocol for performing Diffie-Hellman key exchange"""

    def get_public(self) -> bytes:
        """Return the public key to send to the peer"""

    def get_shared_bytes(self, peer_public: bytes) -> bytes:
        """Return the shared key from the peer's public key in bytes"""

    def get_shared(self, peer_public: bytes) -> int:
        """Return the shared key from the peer's public key"""


_ECDHClass = Callable[..., DHKey]


# pylint: disable=line-too-long

# SSH KEX DH message values
MSG_KEXDH_INIT = 30
MSG_KEXDH_REPLY = 31

# SSH KEX DH group exchange message values
MSG_KEX_DH_GEX_REQUEST_OLD = 30
MSG_KEX_DH_GEX_GROUP = 31
MSG_KEX_DH_GEX_INIT = 32
MSG_KEX_DH_GEX_REPLY = 33
MSG_KEX_DH_GEX_REQUEST = 34

# SSH KEX ECDH message values
MSG_KEX_ECDH_INIT = 30
MSG_KEX_ECDH_REPLY = 31

# SSH KEXGSS message values
MSG_KEXGSS_INIT = 30
MSG_KEXGSS_CONTINUE = 31
MSG_KEXGSS_COMPLETE = 32
MSG_KEXGSS_HOSTKEY = 33
MSG_KEXGSS_ERROR = 34
MSG_KEXGSS_GROUPREQ = 40
MSG_KEXGSS_GROUP = 41

# SSH KEX group exchange key sizes
KEX_DH_GEX_MIN_SIZE = 1024
KEX_DH_GEX_PREFERRED_SIZE = 2048
KEX_DH_GEX_MAX_SIZE = 8192

# SSH Diffie-Hellman group 1 parameters
_group1_g = 2
_group1_p = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF

# SSH Diffie-Hellman group 14 parameters
_group14_g = 2
_group14_p = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF

# SSH Diffie-Hellman group 15 parameters
_group15_g = 2
_group15_p = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF

# SSH Diffie-Hellman group 16 parameters
_group16_g = 2
_group16_p = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199FFFFFFFFFFFFFFFF

# SSH Diffie-Hellman group 17 parameters
_group17_g = 2
_group17_p = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C93402849236C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AACC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E6DCC4024FFFFFFFFFFFFFFFF

# SSH Diffie-Hellman group 18 parameters
_group18_g = 2
_group18_p = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C93402849236C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AACC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E6DBE115974A3926F12FEE5E438777CB6A932DF8CD8BEC4D073B931BA3BC832B68D9DD300741FA7BF8AFC47ED2576F6936BA424663AAB639C5AE4F5683423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD922222E04A4037C0713EB57A81A23F0C73473FC646CEA306B4BCBC8862F8385DDFA9D4B7FA2C087E879683303ED5BDD3A062B3CF5B3A278A66D2A13F83F44F82DDF310EE074AB6A364597E899A0255DC164F31CC50846851DF9AB48195DED7EA1B1D510BD7EE74D73FAF36BC31ECFA268359046F4EB879F924009438B481C6CD7889A002ED5EE382BC9190DA6FC026E479558E4475677E9AA9E3050E2765694DFC81F56E880B96E7160C980DD98EDD3DFFFFFFFFFFFFFFFFF

_dh_gex_groups = (
    (1024, _group1_g, _group1_p),
    (2048, _group14_g, _group14_p),
    (3072, _group15_g, _group15_p),
    (4096, _group16_g, _group16_p),
    (6144, _group17_g, _group17_p),
    (8192, _group18_g, _group18_p),
)

# pylint: enable=line-too-long


class _KexDHBase(Kex):
    """Abstract base class for Diffie-Hellman key exchange"""

    _init_type: int = 0
    _reply_type: int = 0

    def __init__(self, alg: bytes, conn: "SSHConnection", hash_alg: HashType):
        super().__init__(alg, conn, hash_alg)

        self._dh: Optional[DH] = None
        self._g = 0
        self._p = 0
        self._e = 0
        self._f = 0
        self._gex_data = b""

    def _init_group(self, g: int, p: int) -> None:
        """Initialize DH group parameters"""

        self._g = g
        self._p = p

    def _compute_hash(self, host_key_data: bytes, k: bytes) -> bytes:
        """Compute a hash of key information associated with the connection"""

        hash_obj = self._hash_alg()
        hash_obj.update(self._conn.get_hash_prefix())
        hash_obj.update(String(host_key_data))
        hash_obj.update(self._gex_data)
        hash_obj.update(self._format_client_key())
        hash_obj.update(self._format_server_key())
        hash_obj.update(k)
        return hash_obj.digest()

    def _parse_client_key(self, packet: SSHPacket) -> None:
        """Parse a DH client key"""

        if not self._p:
            raise ProtocolError("Kex DH p not specified")

        self._e = packet.get_mpint()

    def _parse_server_key(self, packet: SSHPacket) -> None:
        """Parse a DH server key"""

        if not self._p:
            raise ProtocolError("Kex DH p not specified")

        self._f = packet.get_mpint()

    def _format_client_key(self) -> bytes:
        """Format a DH client key"""

        return MPInt(self._e)

    def _format_server_key(self) -> bytes:
        """Format a DH server key"""

        return MPInt(self._f)

    def _send_init(self) -> None:
        """Send a DH init message"""

        self.send_packet(self._init_type, self._format_client_key())

    def _send_reply(self, key_data: bytes, sig: bytes) -> None:
        """Send a DH reply message"""

        self.send_packet(
            self._reply_type, String(key_data), self._format_server_key(), String(sig)
        )

    def _perform_init(self) -> None:
        """Compute e and send init message"""

        self._dh = DH(self._g, self._p)
        self._e = self._dh.get_public()

        self._send_init()

    def _compute_client_shared(self) -> bytes:
        """Compute client shared key"""

        if not 1 <= self._f < self._p:
            raise ProtocolError("Kex DH f out of range")

        assert self._dh is not None
        return MPInt(self._dh.get_shared(self._f))

    def _compute_server_shared(self) -> bytes:
        """Compute server shared key"""

        if not 1 <= self._e < self._p:
            raise ProtocolError("Kex DH e out of range")

        self._dh = DH(self._g, self._p)
        self._f = self._dh.get_public()

        return MPInt(self._dh.get_shared(self._e))

    def _perform_reply(self, key: SigningKey, key_data: bytes) -> None:
        """Compute server shared key and send reply message"""

        k = self._compute_server_shared()
        h = self._compute_hash(key_data, k)
        self._send_reply(key_data, key.sign(h))

        self._conn.send_newkeys(k, h)

    def _verify_reply(self, key: VerifyingKey, key_data: bytes, sig: bytes) -> None:
        """Verify a DH reply message"""

        k = self._compute_client_shared()
        h = self._compute_hash(key_data, k)

        if not key.verify(h, sig):
            raise KeyExchangeFailed("Key exchange hash mismatch")

        self._conn.send_newkeys(k, h)

    def _process_init(self, _pkttype: int, _pktid: int, packet: SSHPacket) -> None:
        """Process a DH init message"""

        if self._conn.is_client():
            raise ProtocolError("Unexpected kex init msg")

        self._parse_client_key(packet)
        packet.check_end()

        server_conn = cast("SSHServerConnection", self._conn)
        host_key = server_conn.get_server_host_key()
        assert host_key is not None

        self._perform_reply(host_key, host_key.public_data)

    def _process_reply(self, _pkttype: int, _pktid: int, packet: SSHPacket) -> None:
        """Process a DH reply message"""

        if self._conn.is_server():
            raise ProtocolError("Unexpected kex reply msg")

        host_key_data = packet.get_string()
        self._parse_server_key(packet)
        sig = packet.get_string()
        packet.check_end()

        client_conn = cast("SSHClientConnection", self._conn)
        host_key = client_conn.validate_server_host_key(host_key_data)
        self._verify_reply(host_key, host_key_data, sig)

    async def start(self) -> None:
        """Start DH key exchange"""

        if self._conn.is_client():
            self._perform_init()


class _KexDH(_KexDHBase):
    """Handler for Diffie-Hellman key exchange"""

    _handler_names = get_symbol_names(globals(), "MSG_KEXDH_")

    _init_type = MSG_KEXDH_INIT
    _reply_type = MSG_KEXDH_REPLY

    def __init__(
        self, alg: bytes, conn: "SSHConnection", hash_alg: HashType, g: int, p: int
    ):
        super().__init__(alg, conn, hash_alg)

        self._init_group(g, p)

    _packet_handlers: Mapping[int, Callable] = {
        MSG_KEXDH_INIT: _KexDHBase._process_init,
        MSG_KEXDH_REPLY: _KexDHBase._process_reply,
    }


class _KexDHGex(_KexDHBase):
    """Handler for Diffie-Hellman group exchange"""

    _handler_names = get_symbol_names(globals(), "MSG_KEX_DH_GEX_")

    _init_type = MSG_KEX_DH_GEX_INIT
    _reply_type = MSG_KEX_DH_GEX_REPLY
    _request_type = MSG_KEX_DH_GEX_REQUEST
    _group_type = MSG_KEX_DH_GEX_GROUP

    def __init__(
        self,
        alg: bytes,
        conn: "SSHConnection",
        hash_alg: HashType,
        preferred_size: Optional[int] = None,
        max_size: Optional[int] = None,
    ):
        super().__init__(alg, conn, hash_alg)

        self._pref_size = preferred_size
        self._max_size = max_size

    def _send_request(self) -> None:
        """Send a DH gex request message"""

        if self._pref_size and not self._max_size:
            # Send old request message for unit test
            pkttype = MSG_KEX_DH_GEX_REQUEST_OLD
            args = UInt32(self._pref_size)
        else:
            pkttype = self._request_type
            args = (
                UInt32(KEX_DH_GEX_MIN_SIZE)
                + UInt32(self._pref_size or KEX_DH_GEX_PREFERRED_SIZE)
                + UInt32(self._max_size or KEX_DH_GEX_MAX_SIZE)
            )

        self._gex_data = args
        self.send_packet(pkttype, args)

    def _process_request(self, pkttype: int, _pktid: int, packet: SSHPacket) -> None:
        """Process a DH gex request message"""

        if self._conn.is_client():
            raise ProtocolError("Unexpected kex request msg")

        self._gex_data = packet.get_remaining_payload()

        if pkttype == MSG_KEX_DH_GEX_REQUEST_OLD:
            preferred_size = packet.get_uint32()
            max_size = KEX_DH_GEX_MAX_SIZE
        else:
            _ = packet.get_uint32()
            preferred_size = packet.get_uint32()
            max_size = packet.get_uint32()

        packet.check_end()

        g, p = _group1_g, _group1_p

        for gex_size, gex_g, gex_p in _dh_gex_groups:
            if gex_size > max_size:
                break
            else:
                g, p = gex_g, gex_p

                if gex_size >= preferred_size:
                    break

        self._init_group(g, p)
        self._gex_data += MPInt(p) + MPInt(g)
        self.send_packet(self._group_type, MPInt(p), MPInt(g))

    def _process_group(self, _pkttype: int, _pktid: int, packet: SSHPacket) -> None:
        """Process a DH gex group message"""

        if self._conn.is_server():
            raise ProtocolError("Unexpected kex group msg")

        p = packet.get_mpint()
        g = packet.get_mpint()
        packet.check_end()

        self._init_group(g, p)
        self._gex_data += MPInt(p) + MPInt(g)
        self._perform_init()

    async def start(self) -> None:
        """Start DH group exchange"""

        if self._conn.is_client():
            self._send_request()

    _packet_handlers: Mapping[int, Callable] = {
        MSG_KEX_DH_GEX_REQUEST_OLD: _process_request,
        MSG_KEX_DH_GEX_GROUP: _process_group,
        MSG_KEX_DH_GEX_INIT: _KexDHBase._process_init,
        MSG_KEX_DH_GEX_REPLY: _KexDHBase._process_reply,
        MSG_KEX_DH_GEX_REQUEST: _process_request,
    }


class _KexECDH(_KexDHBase):
    """Handler for elliptic curve Diffie-Hellman key exchange"""

    _handler_names = get_symbol_names(globals(), "MSG_KEX_ECDH_")

    _init_type = MSG_KEX_ECDH_INIT
    _reply_type = MSG_KEX_ECDH_REPLY

    def __init__(
        self,
        alg: bytes,
        conn: "SSHConnection",
        hash_alg: HashType,
        ecdh_class: _ECDHClass,
        *args: object
    ):
        super().__init__(alg, conn, hash_alg)

        self._priv = ecdh_class(*args)
        pub = self._priv.get_public()

        if conn.is_client():
            self._client_pub = pub
        else:
            self._server_pub = pub

    def _parse_client_key(self, packet: SSHPacket) -> None:
        """Parse an ECDH client key"""

        self._client_pub = packet.get_string()

    def _parse_server_key(self, packet: SSHPacket) -> None:
        """Parse an ECDH server key"""

        self._server_pub = packet.get_string()

    def _format_client_key(self) -> bytes:
        """Format an ECDH client key"""

        return String(self._client_pub)

    def _format_server_key(self) -> bytes:
        """Format an ECDH server key"""

        return String(self._server_pub)

    def _compute_client_shared(self) -> bytes:
        """Compute client shared key"""

        try:
            return MPInt(self._priv.get_shared(self._server_pub))
        except ValueError:
            raise ProtocolError("Invalid ECDH server public key") from None

    def _compute_server_shared(self) -> bytes:
        """Compute server shared key"""

        try:
            return MPInt(self._priv.get_shared(self._client_pub))
        except ValueError:
            raise ProtocolError("Invalid ECDH client public key") from None

    async def start(self) -> None:
        """Start ECDH key exchange"""

        if self._conn.is_client():
            self._send_init()

    _packet_handlers: Mapping[int, Callable] = {
        MSG_KEX_ECDH_INIT: _KexDHBase._process_init,
        MSG_KEX_ECDH_REPLY: _KexDHBase._process_reply,
    }


class _KexHybridECDH(_KexECDH):
    """Handler for post-quantum key exchange"""

    def __init__(
        self,
        alg: bytes,
        conn: "SSHConnection",
        hash_alg: HashType,
        pq_alg_name: bytes,
        ecdh_class: _ECDHClass,
        *args: object
    ):
        super().__init__(alg, conn, hash_alg, ecdh_class, *args)

        self._pq = PQDH(pq_alg_name)

        if conn.is_client():
            pq_pub, self._pq_priv = self._pq.keypair()
            self._client_pub = pq_pub + self._client_pub

    def _compute_client_shared(self) -> bytes:
        """Compute client shared key"""

        pq_ciphertext = self._server_pub[: self._pq.ciphertext_bytes]
        ec_pub = self._server_pub[self._pq.ciphertext_bytes :]

        try:
            pq_secret = self._pq.decaps(pq_ciphertext, self._pq_priv)
        except ValueError:
            raise ProtocolError("Invalid PQ server ciphertext") from None

        try:
            ec_shared = self._priv.get_shared_bytes(ec_pub)
        except ValueError:
            raise ProtocolError("Invalid ECDH server public key") from None

        return String(self._hash_alg(pq_secret + ec_shared).digest())

    def _compute_server_shared(self) -> bytes:
        """Compute server shared key"""

        pq_pub = self._client_pub[: self._pq.pubkey_bytes]
        ec_pub = self._client_pub[self._pq.pubkey_bytes :]

        try:
            pq_secret, pq_ciphertext = self._pq.encaps(pq_pub)
        except ValueError:
            raise ProtocolError("Invalid PQ client public key") from None

        try:
            ec_shared = self._priv.get_shared_bytes(ec_pub)
        except ValueError:
            raise ProtocolError("Invalid ECDH client public key") from None

        self._server_pub = pq_ciphertext + self._server_pub

        return String(self._hash_alg(pq_secret + ec_shared).digest())


class _KexGSSBase(_KexDHBase):
    """Handler for GSS key exchange"""

    def __init__(
        self, alg: bytes, conn: "SSHConnection", hash_alg: HashType, *args: object
    ):
        super().__init__(alg, conn, hash_alg, *args)

        self._gss = conn.get_gss_context()
        self._token: Optional[bytes] = None
        self._host_key_data = b""

    def _check_secure(self) -> None:
        """Check that GSS context is secure enough for key exchange"""

        if not self._gss.provides_mutual_auth or not self._gss.provides_integrity:
            raise ProtocolError("GSS context not secure")

    def _send_init(self) -> None:
        """Send a GSS init message"""

        if not self._token:
            raise ProtocolError("Empty GSS token in init")

        self.send_packet(
            MSG_KEXGSS_INIT, String(self._token), self._format_client_key()
        )

    def _send_reply(self, key_data: bytes, sig: bytes) -> None:
        """Send a GSS reply message"""

        if self._token:
            token_data = Boolean(True) + String(self._token)
        else:
            token_data = Boolean(False)

        self.send_packet(
            MSG_KEXGSS_COMPLETE, self._format_server_key(), String(sig), token_data
        )

    def _send_continue(self) -> None:
        """Send a GSS continue message"""

        if not self._token:
            raise ProtocolError("Empty GSS token in continue")

        self.send_packet(MSG_KEXGSS_CONTINUE, String(self._token))

    async def _process_token(self, token: Optional[bytes] = None) -> None:
        """Process a GSS token"""

        try:
            self._token = await run_in_executor(self._gss.step, token)
        except GSSError as exc:
            if self._conn.is_server():
                self.send_packet(
                    MSG_KEXGSS_ERROR,
                    UInt32(exc.maj_code),
                    UInt32(exc.min_code),
                    String(str(exc)),
                    String(DEFAULT_LANG),
                )

            if exc.token:
                self.send_packet(MSG_KEXGSS_CONTINUE, String(exc.token))

            raise KeyExchangeFailed(str(exc)) from None

    async def _process_gss_init(
        self, _pkttype: int, _pktid: int, packet: SSHPacket
    ) -> None:
        """Process a GSS init message"""

        if self._conn.is_client():
            raise ProtocolError("Unexpected kexgss init msg")

        token = packet.get_string()
        self._parse_client_key(packet)
        packet.check_end()

        server_conn = cast("SSHServerConnection", self._conn)
        host_key = server_conn.get_server_host_key()

        if host_key:
            self._host_key_data = host_key.public_data
            self.send_packet(MSG_KEXGSS_HOSTKEY, String(self._host_key_data))
        else:
            self._host_key_data = b""

        await self._process_token(token)

        if self._gss.complete:
            self._check_secure()
            self._perform_reply(self._gss, self._host_key_data)
            self._conn.enable_gss_kex_auth()
        else:
            self._send_continue()

    async def _process_continue(
        self, _pkttype: int, _pktid: int, packet: SSHPacket
    ) -> None:
        """Process a GSS continue message"""

        token = packet.get_string()
        packet.check_end()

        if self._conn.is_client() and self._gss.complete:
            raise ProtocolError("Unexpected kexgss continue msg")

        await self._process_token(token)

        if self._conn.is_server() and self._gss.complete:
            self._check_secure()
            self._perform_reply(self._gss, self._host_key_data)
        else:
            self._send_continue()

    async def _process_complete(
        self, _pkttype: int, _pktid: int, packet: SSHPacket
    ) -> None:
        """Process a GSS complete message"""

        if self._conn.is_server():
            raise ProtocolError("Unexpected kexgss complete msg")

        self._parse_server_key(packet)
        mic = packet.get_string()
        token_present = packet.get_boolean()
        token = packet.get_string() if token_present else None
        packet.check_end()

        if token:
            if self._gss.complete:
                raise ProtocolError("Non-empty token after complete")

            await self._process_token(token)

            if self._token:
                raise ProtocolError("Non-empty token after complete")

        if not self._gss.complete:
            raise ProtocolError("GSS exchange failed to complete")

        self._check_secure()
        self._verify_reply(self._gss, self._host_key_data, mic)
        self._conn.enable_gss_kex_auth()

    def _process_hostkey(self, _pkttype: int, _pktid: int, packet: SSHPacket) -> None:
        """Process a GSS hostkey message"""

        self._host_key_data = packet.get_string()
        packet.check_end()

    def _process_error(self, _pkttype: int, _pktid: int, packet: SSHPacket) -> None:
        """Process a GSS error message"""

        if self._conn.is_server():
            raise ProtocolError("Unexpected kexgss error msg")

        _ = packet.get_uint32()  # major_status
        _ = packet.get_uint32()  # minor_status
        msg = packet.get_string()
        _ = packet.get_string()  # lang
        packet.check_end()

        self._conn.logger.debug1("GSS error: %s", msg.decode("utf-8", errors="ignore"))

    async def start(self) -> None:
        """Start GSS key exchange"""

        if self._conn.is_client():
            await self._process_token()
            await super().start()


class _KexGSS(_KexGSSBase, _KexDH):
    """Handler for GSS key exchange"""

    _handler_names = get_symbol_names(globals(), "MSG_KEXGSS_")

    _packet_handlers = {
        MSG_KEXGSS_INIT: _KexGSSBase._process_gss_init,
        MSG_KEXGSS_CONTINUE: _KexGSSBase._process_continue,
        MSG_KEXGSS_COMPLETE: _KexGSSBase._process_complete,
        MSG_KEXGSS_HOSTKEY: _KexGSSBase._process_hostkey,
        MSG_KEXGSS_ERROR: _KexGSSBase._process_error,
    }


class _KexGSSGex(_KexGSSBase, _KexDHGex):
    """Handler for GSS group exchange"""

    _handler_names = get_symbol_names(globals(), "MSG_KEXGSS_")

    _request_type = MSG_KEXGSS_GROUPREQ
    _group_type = MSG_KEXGSS_GROUP

    _packet_handlers = {
        MSG_KEXGSS_INIT: _KexGSSBase._process_gss_init,
        MSG_KEXGSS_CONTINUE: _KexGSSBase._process_continue,
        MSG_KEXGSS_COMPLETE: _KexGSSBase._process_complete,
        MSG_KEXGSS_HOSTKEY: _KexGSSBase._process_hostkey,
        MSG_KEXGSS_ERROR: _KexGSSBase._process_error,
        MSG_KEXGSS_GROUPREQ: _KexDHGex._process_request,
        MSG_KEXGSS_GROUP: _KexDHGex._process_group,
    }


class _KexGSSECDH(_KexGSSBase, _KexECDH):
    """Handler for GSS ECDH key exchange"""

    _handler_names = get_symbol_names(globals(), "MSG_KEXGSS_")

    _packet_handlers = {
        MSG_KEXGSS_INIT: _KexGSSBase._process_gss_init,
        MSG_KEXGSS_CONTINUE: _KexGSSBase._process_continue,
        MSG_KEXGSS_COMPLETE: _KexGSSBase._process_complete,
        MSG_KEXGSS_HOSTKEY: _KexGSSBase._process_hostkey,
        MSG_KEXGSS_ERROR: _KexGSSBase._process_error,
    }


if mlkem_available:  # pragma: no branch
    if curve25519_available:  # pragma: no branch
        register_kex_alg(
            b"mlkem768x25519-sha256",
            _KexHybridECDH,
            sha256,
            (b"mlkem768", Curve25519DH),
            True,
        )

    register_kex_alg(
        b"mlkem768nistp256-sha256",
        _KexHybridECDH,
        sha256,
        (b"mlkem768", ECDH, b"nistp256"),
        True,
    )
    register_kex_alg(
        b"mlkem1024nistp384-sha384",
        _KexHybridECDH,
        sha384,
        (b"mlkem1024", ECDH, b"nistp384"),
        True,
    )

if curve25519_available:  # pragma: no branch
    if sntrup_available:  # pragma: no branch
        register_kex_alg(
            b"sntrup761x25519-sha512",
            _KexHybridECDH,
            sha512,
            (b"sntrup761", Curve25519DH),
            True,
        )
        register_kex_alg(
            b"sntrup761x25519-sha512@openssh.com",
            _KexHybridECDH,
            sha512,
            (b"sntrup761", Curve25519DH),
            True,
        )

    register_kex_alg(b"curve25519-sha256", _KexECDH, sha256, (Curve25519DH,), True)
    register_kex_alg(
        b"curve25519-sha256@libssh.org", _KexECDH, sha256, (Curve25519DH,), True
    )
    register_gss_kex_alg(
        b"gss-curve25519-sha256", _KexGSSECDH, sha256, (Curve25519DH,), True
    )

if curve448_available:  # pragma: no branch
    register_kex_alg(b"curve448-sha512", _KexECDH, sha512, (Curve448DH,), True)
    register_gss_kex_alg(
        b"gss-curve448-sha512", _KexGSSECDH, sha512, (Curve448DH,), True
    )

for _curve_id, _hash_name, _hash_alg, _default in (
    (b"nistp521", b"sha512", sha512, True),
    (b"nistp384", b"sha384", sha384, True),
    (b"nistp256", b"sha256", sha256, True),
    (b"1.3.132.0.10", b"sha256", sha256, True),
):
    register_kex_alg(
        b"ecdh-sha2-" + _curve_id, _KexECDH, _hash_alg, (ECDH, _curve_id), _default
    )
    register_gss_kex_alg(
        b"gss-" + _curve_id + b"-" + _hash_name,
        _KexGSSECDH,
        _hash_alg,
        (ECDH, _curve_id),
        _default,
    )

for _hash_name, _hash_alg, _default in (
    (b"sha256", sha256, True),
    (b"sha224@ssh.com", sha224, False),
    (b"sha384@ssh.com", sha384, False),
    (b"sha512@ssh.com", sha512, False),
    (b"sha1", sha1, False),
):
    register_kex_alg(
        b"diffie-hellman-group-exchange-" + _hash_name,
        _KexDHGex,
        _hash_alg,
        (),
        _default,
    )

    if not _hash_name.endswith(b"@ssh.com"):
        register_gss_kex_alg(
            b"gss-gex-" + _hash_name, _KexGSSGex, _hash_alg, (), _default
        )

for _name, _hash_alg, _g, _p, _default in (
    (b"group14-sha256", sha256, _group14_g, _group14_p, True),
    (b"group15-sha512", sha512, _group15_g, _group15_p, True),
    (b"group16-sha512", sha512, _group16_g, _group16_p, True),
    (b"group17-sha512", sha512, _group17_g, _group17_p, True),
    (b"group18-sha512", sha512, _group18_g, _group18_p, True),
    (b"group14-sha256@ssh.com", sha256, _group14_g, _group14_p, True),
    (b"group14-sha224@ssh.com", sha224, _group14_g, _group14_p, False),
    (b"group15-sha256@ssh.com", sha256, _group15_g, _group15_p, False),
    (b"group15-sha384@ssh.com", sha384, _group15_g, _group15_p, False),
    (b"group16-sha384@ssh.com", sha384, _group16_g, _group16_p, False),
    (b"group16-sha512@ssh.com", sha512, _group16_g, _group16_p, False),
    (b"group18-sha512@ssh.com", sha512, _group18_g, _group18_p, False),
    (b"group14-sha1", sha1, _group14_g, _group14_p, True),
    (b"group1-sha1", sha1, _group1_g, _group1_p, False),
):
    register_kex_alg(b"diffie-hellman-" + _name, _KexDH, _hash_alg, (_g, _p), _default)

    if not _name.endswith(b"@ssh.com"):
        register_gss_kex_alg(b"gss-" + _name, _KexGSS, _hash_alg, (_g, _p), _default)
